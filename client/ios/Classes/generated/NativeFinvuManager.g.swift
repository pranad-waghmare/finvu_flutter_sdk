// Autogenerated from Pigeon (v26.0.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsNativeFinvuManager(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsNativeFinvuManager(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsNativeFinvuManager(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashNativeFinvuManager(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashNativeFinvuManager(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashNativeFinvuManager(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

enum FinvuEnv: Int {
  case uat = 0
  case production = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFinvuSnaAuthConfig: Hashable {
  var environment: FinvuEnv


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFinvuSnaAuthConfig? {
    let environment = pigeonVar_list[0] as! FinvuEnv

    return NativeFinvuSnaAuthConfig(
      environment: environment
    )
  }
  func toList() -> [Any?] {
    return [
      environment
    ]
  }
  static func == (lhs: NativeFinvuSnaAuthConfig, rhs: NativeFinvuSnaAuthConfig) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFinvuConfig: Hashable {
  var finvuEndpoint: String
  var certificatePins: [String?]? = nil
  var finvuSnaAuthConfig: NativeFinvuSnaAuthConfig? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFinvuConfig? {
    let finvuEndpoint = pigeonVar_list[0] as! String
    let certificatePins: [String?]? = nilOrValue(pigeonVar_list[1])
    let finvuSnaAuthConfig: NativeFinvuSnaAuthConfig? = nilOrValue(pigeonVar_list[2])

    return NativeFinvuConfig(
      finvuEndpoint: finvuEndpoint,
      certificatePins: certificatePins,
      finvuSnaAuthConfig: finvuSnaAuthConfig
    )
  }
  func toList() -> [Any?] {
    return [
      finvuEndpoint,
      certificatePins,
      finvuSnaAuthConfig,
    ]
  }
  static func == (lhs: NativeFinvuConfig, rhs: NativeFinvuConfig) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeHandleInfo: Hashable {
  var userId: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeHandleInfo? {
    let userId = pigeonVar_list[0] as! String

    return NativeHandleInfo(
      userId: userId
    )
  }
  func toList() -> [Any?] {
    return [
      userId
    ]
  }
  static func == (lhs: NativeHandleInfo, rhs: NativeHandleInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPDetails: Hashable {
  var fipId: String
  var typeIdentifiers: [NativeFIPFiTypeIdentifier?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFIPDetails? {
    let fipId = pigeonVar_list[0] as! String
    let typeIdentifiers = pigeonVar_list[1] as! [NativeFIPFiTypeIdentifier?]

    return NativeFIPDetails(
      fipId: fipId,
      typeIdentifiers: typeIdentifiers
    )
  }
  func toList() -> [Any?] {
    return [
      fipId,
      typeIdentifiers,
    ]
  }
  static func == (lhs: NativeFIPDetails, rhs: NativeFIPDetails) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPFiTypeIdentifier: Hashable {
  var fiType: String
  var identifiers: [NativeTypeIdentifier?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFIPFiTypeIdentifier? {
    let fiType = pigeonVar_list[0] as! String
    let identifiers = pigeonVar_list[1] as! [NativeTypeIdentifier?]

    return NativeFIPFiTypeIdentifier(
      fiType: fiType,
      identifiers: identifiers
    )
  }
  func toList() -> [Any?] {
    return [
      fiType,
      identifiers,
    ]
  }
  static func == (lhs: NativeFIPFiTypeIdentifier, rhs: NativeFIPFiTypeIdentifier) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeTypeIdentifier: Hashable {
  var type: String
  var category: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeTypeIdentifier? {
    let type = pigeonVar_list[0] as! String
    let category = pigeonVar_list[1] as! String

    return NativeTypeIdentifier(
      type: type,
      category: category
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      category,
    ]
  }
  static func == (lhs: NativeTypeIdentifier, rhs: NativeTypeIdentifier) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeTypeIdentifierInfo: Hashable {
  var category: String
  var type: String
  var value: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeTypeIdentifierInfo? {
    let category = pigeonVar_list[0] as! String
    let type = pigeonVar_list[1] as! String
    let value = pigeonVar_list[2] as! String

    return NativeTypeIdentifierInfo(
      category: category,
      type: type,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      category,
      type,
      value,
    ]
  }
  static func == (lhs: NativeTypeIdentifierInfo, rhs: NativeTypeIdentifierInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeDiscoveredAccountInfo: Hashable {
  var accountType: String
  var accountReferenceNumber: String
  var maskedAccountNumber: String
  var fiType: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeDiscoveredAccountInfo? {
    let accountType = pigeonVar_list[0] as! String
    let accountReferenceNumber = pigeonVar_list[1] as! String
    let maskedAccountNumber = pigeonVar_list[2] as! String
    let fiType = pigeonVar_list[3] as! String

    return NativeDiscoveredAccountInfo(
      accountType: accountType,
      accountReferenceNumber: accountReferenceNumber,
      maskedAccountNumber: maskedAccountNumber,
      fiType: fiType
    )
  }
  func toList() -> [Any?] {
    return [
      accountType,
      accountReferenceNumber,
      maskedAccountNumber,
      fiType,
    ]
  }
  static func == (lhs: NativeDiscoveredAccountInfo, rhs: NativeDiscoveredAccountInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeDiscoveredAccountsResponse: Hashable {
  var accounts: [NativeDiscoveredAccountInfo?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeDiscoveredAccountsResponse? {
    let accounts = pigeonVar_list[0] as! [NativeDiscoveredAccountInfo?]

    return NativeDiscoveredAccountsResponse(
      accounts: accounts
    )
  }
  func toList() -> [Any?] {
    return [
      accounts
    ]
  }
  static func == (lhs: NativeDiscoveredAccountsResponse, rhs: NativeDiscoveredAccountsResponse) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAccountLinkingRequestReference: Hashable {
  var referenceNumber: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeAccountLinkingRequestReference? {
    let referenceNumber = pigeonVar_list[0] as! String

    return NativeAccountLinkingRequestReference(
      referenceNumber: referenceNumber
    )
  }
  func toList() -> [Any?] {
    return [
      referenceNumber
    ]
  }
  static func == (lhs: NativeAccountLinkingRequestReference, rhs: NativeAccountLinkingRequestReference) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLinkedAccountInfo: Hashable {
  var customerAddress: String
  var linkReferenceNumber: String
  var accountReferenceNumber: String
  var status: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeLinkedAccountInfo? {
    let customerAddress = pigeonVar_list[0] as! String
    let linkReferenceNumber = pigeonVar_list[1] as! String
    let accountReferenceNumber = pigeonVar_list[2] as! String
    let status = pigeonVar_list[3] as! String

    return NativeLinkedAccountInfo(
      customerAddress: customerAddress,
      linkReferenceNumber: linkReferenceNumber,
      accountReferenceNumber: accountReferenceNumber,
      status: status
    )
  }
  func toList() -> [Any?] {
    return [
      customerAddress,
      linkReferenceNumber,
      accountReferenceNumber,
      status,
    ]
  }
  static func == (lhs: NativeLinkedAccountInfo, rhs: NativeLinkedAccountInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConfirmAccountLinkingInfo: Hashable {
  var linkedAccounts: [NativeLinkedAccountInfo?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConfirmAccountLinkingInfo? {
    let linkedAccounts = pigeonVar_list[0] as! [NativeLinkedAccountInfo?]

    return NativeConfirmAccountLinkingInfo(
      linkedAccounts: linkedAccounts
    )
  }
  func toList() -> [Any?] {
    return [
      linkedAccounts
    ]
  }
  static func == (lhs: NativeConfirmAccountLinkingInfo, rhs: NativeConfirmAccountLinkingInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLinkedAccountsResponse: Hashable {
  var linkedAccounts: [NativeLinkedAccountDetailsInfo?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeLinkedAccountsResponse? {
    let linkedAccounts = pigeonVar_list[0] as! [NativeLinkedAccountDetailsInfo?]

    return NativeLinkedAccountsResponse(
      linkedAccounts: linkedAccounts
    )
  }
  func toList() -> [Any?] {
    return [
      linkedAccounts
    ]
  }
  static func == (lhs: NativeLinkedAccountsResponse, rhs: NativeLinkedAccountsResponse) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLinkedAccountDetailsInfo: Hashable {
  var userId: String
  var fipId: String
  var fipName: String
  var maskedAccountNumber: String
  var accountReferenceNumber: String
  var linkReferenceNumber: String
  var consentIdList: [String?]? = nil
  var fiType: String
  var accountType: String
  var linkedAccountUpdateTimestamp: String? = nil
  var authenticatorType: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeLinkedAccountDetailsInfo? {
    let userId = pigeonVar_list[0] as! String
    let fipId = pigeonVar_list[1] as! String
    let fipName = pigeonVar_list[2] as! String
    let maskedAccountNumber = pigeonVar_list[3] as! String
    let accountReferenceNumber = pigeonVar_list[4] as! String
    let linkReferenceNumber = pigeonVar_list[5] as! String
    let consentIdList: [String?]? = nilOrValue(pigeonVar_list[6])
    let fiType = pigeonVar_list[7] as! String
    let accountType = pigeonVar_list[8] as! String
    let linkedAccountUpdateTimestamp: String? = nilOrValue(pigeonVar_list[9])
    let authenticatorType = pigeonVar_list[10] as! String

    return NativeLinkedAccountDetailsInfo(
      userId: userId,
      fipId: fipId,
      fipName: fipName,
      maskedAccountNumber: maskedAccountNumber,
      accountReferenceNumber: accountReferenceNumber,
      linkReferenceNumber: linkReferenceNumber,
      consentIdList: consentIdList,
      fiType: fiType,
      accountType: accountType,
      linkedAccountUpdateTimestamp: linkedAccountUpdateTimestamp,
      authenticatorType: authenticatorType
    )
  }
  func toList() -> [Any?] {
    return [
      userId,
      fipId,
      fipName,
      maskedAccountNumber,
      accountReferenceNumber,
      linkReferenceNumber,
      consentIdList,
      fiType,
      accountType,
      linkedAccountUpdateTimestamp,
      authenticatorType,
    ]
  }
  static func == (lhs: NativeLinkedAccountDetailsInfo, rhs: NativeLinkedAccountDetailsInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFinancialInformationEntity: Hashable {
  var id: String
  var name: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFinancialInformationEntity? {
    let id = pigeonVar_list[0] as! String
    let name = pigeonVar_list[1] as! String

    return NativeFinancialInformationEntity(
      id: id,
      name: name
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      name,
    ]
  }
  static func == (lhs: NativeFinancialInformationEntity, rhs: NativeFinancialInformationEntity) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentPurposeInfo: Hashable {
  var code: String
  var text: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConsentPurposeInfo? {
    let code = pigeonVar_list[0] as! String
    let text = pigeonVar_list[1] as! String

    return NativeConsentPurposeInfo(
      code: code,
      text: text
    )
  }
  func toList() -> [Any?] {
    return [
      code,
      text,
    ]
  }
  static func == (lhs: NativeConsentPurposeInfo, rhs: NativeConsentPurposeInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentRequestDetailInfo: Hashable {
  var consentHandleId: String
  var consentId: String? = nil
  var financialInformationUser: NativeFinancialInformationEntity
  var consentPurposeInfo: NativeConsentPurposeInfo
  var consentDisplayDescriptions: [String?]
  var dataDateTimeRange: NativeDateTimeRange
  var consentDateTimeRange: NativeDateTimeRange
  var consentDataFrequency: NativeConsentDataFrequency
  var consentDataLifePeriod: NativeConsentDataLifePeriod
  var fiTypes: [String?]? = nil
  var statusLastUpdateTimestamp: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConsentRequestDetailInfo? {
    let consentHandleId = pigeonVar_list[0] as! String
    let consentId: String? = nilOrValue(pigeonVar_list[1])
    let financialInformationUser = pigeonVar_list[2] as! NativeFinancialInformationEntity
    let consentPurposeInfo = pigeonVar_list[3] as! NativeConsentPurposeInfo
    let consentDisplayDescriptions = pigeonVar_list[4] as! [String?]
    let dataDateTimeRange = pigeonVar_list[5] as! NativeDateTimeRange
    let consentDateTimeRange = pigeonVar_list[6] as! NativeDateTimeRange
    let consentDataFrequency = pigeonVar_list[7] as! NativeConsentDataFrequency
    let consentDataLifePeriod = pigeonVar_list[8] as! NativeConsentDataLifePeriod
    let fiTypes: [String?]? = nilOrValue(pigeonVar_list[9])
    let statusLastUpdateTimestamp: String? = nilOrValue(pigeonVar_list[10])

    return NativeConsentRequestDetailInfo(
      consentHandleId: consentHandleId,
      consentId: consentId,
      financialInformationUser: financialInformationUser,
      consentPurposeInfo: consentPurposeInfo,
      consentDisplayDescriptions: consentDisplayDescriptions,
      dataDateTimeRange: dataDateTimeRange,
      consentDateTimeRange: consentDateTimeRange,
      consentDataFrequency: consentDataFrequency,
      consentDataLifePeriod: consentDataLifePeriod,
      fiTypes: fiTypes,
      statusLastUpdateTimestamp: statusLastUpdateTimestamp
    )
  }
  func toList() -> [Any?] {
    return [
      consentHandleId,
      consentId,
      financialInformationUser,
      consentPurposeInfo,
      consentDisplayDescriptions,
      dataDateTimeRange,
      consentDateTimeRange,
      consentDataFrequency,
      consentDataLifePeriod,
      fiTypes,
      statusLastUpdateTimestamp,
    ]
  }
  static func == (lhs: NativeConsentRequestDetailInfo, rhs: NativeConsentRequestDetailInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeDateTimeRange: Hashable {
  var from: String
  var to: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeDateTimeRange? {
    let from = pigeonVar_list[0] as! String
    let to = pigeonVar_list[1] as! String

    return NativeDateTimeRange(
      from: from,
      to: to
    )
  }
  func toList() -> [Any?] {
    return [
      from,
      to,
    ]
  }
  static func == (lhs: NativeDateTimeRange, rhs: NativeDateTimeRange) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentDataFrequency: Hashable {
  var unit: String
  var value: Double


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConsentDataFrequency? {
    let unit = pigeonVar_list[0] as! String
    let value = pigeonVar_list[1] as! Double

    return NativeConsentDataFrequency(
      unit: unit,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      unit,
      value,
    ]
  }
  static func == (lhs: NativeConsentDataFrequency, rhs: NativeConsentDataFrequency) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentDataLifePeriod: Hashable {
  var unit: String
  var value: Double


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConsentDataLifePeriod? {
    let unit = pigeonVar_list[0] as! String
    let value = pigeonVar_list[1] as! Double

    return NativeConsentDataLifePeriod(
      unit: unit,
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      unit,
      value,
    ]
  }
  static func == (lhs: NativeConsentDataLifePeriod, rhs: NativeConsentDataLifePeriod) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentInfo: Hashable {
  var consentId: String
  var fipId: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConsentInfo? {
    let consentId = pigeonVar_list[0] as! String
    let fipId: String? = nilOrValue(pigeonVar_list[1])

    return NativeConsentInfo(
      consentId: consentId,
      fipId: fipId
    )
  }
  func toList() -> [Any?] {
    return [
      consentId,
      fipId,
    ]
  }
  static func == (lhs: NativeConsentInfo, rhs: NativeConsentInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeProcessConsentRequestResponse: Hashable {
  var consentIntentId: String? = nil
  var consentInfo: [NativeConsentInfo?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeProcessConsentRequestResponse? {
    let consentIntentId: String? = nilOrValue(pigeonVar_list[0])
    let consentInfo: [NativeConsentInfo?]? = nilOrValue(pigeonVar_list[1])

    return NativeProcessConsentRequestResponse(
      consentIntentId: consentIntentId,
      consentInfo: consentInfo
    )
  }
  func toList() -> [Any?] {
    return [
      consentIntentId,
      consentInfo,
    ]
  }
  static func == (lhs: NativeProcessConsentRequestResponse, rhs: NativeProcessConsentRequestResponse) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserConsentInfo: Hashable {
  var consentIntentId: String
  var consentIntentEntityId: String? = nil
  var consentIntentEntityName: String
  var consentIdList: [String?]
  var consentIntentUpdateTimestamp: String
  var consentPurposeText: String
  var status: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeUserConsentInfo? {
    let consentIntentId = pigeonVar_list[0] as! String
    let consentIntentEntityId: String? = nilOrValue(pigeonVar_list[1])
    let consentIntentEntityName = pigeonVar_list[2] as! String
    let consentIdList = pigeonVar_list[3] as! [String?]
    let consentIntentUpdateTimestamp = pigeonVar_list[4] as! String
    let consentPurposeText = pigeonVar_list[5] as! String
    let status: String? = nilOrValue(pigeonVar_list[6])

    return NativeUserConsentInfo(
      consentIntentId: consentIntentId,
      consentIntentEntityId: consentIntentEntityId,
      consentIntentEntityName: consentIntentEntityName,
      consentIdList: consentIdList,
      consentIntentUpdateTimestamp: consentIntentUpdateTimestamp,
      consentPurposeText: consentPurposeText,
      status: status
    )
  }
  func toList() -> [Any?] {
    return [
      consentIntentId,
      consentIntentEntityId,
      consentIntentEntityName,
      consentIdList,
      consentIntentUpdateTimestamp,
      consentPurposeText,
      status,
    ]
  }
  static func == (lhs: NativeUserConsentInfo, rhs: NativeUserConsentInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeUserConsentInfoDetails: Hashable {
  var consentId: String
  var consentIntentEntityId: String? = nil
  var consentIntentEntityName: String
  var consentIdList: [String?]
  var consentIntentUpdateTimestamp: String
  var consentPurposeText: String
  var status: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeUserConsentInfoDetails? {
    let consentId = pigeonVar_list[0] as! String
    let consentIntentEntityId: String? = nilOrValue(pigeonVar_list[1])
    let consentIntentEntityName = pigeonVar_list[2] as! String
    let consentIdList = pigeonVar_list[3] as! [String?]
    let consentIntentUpdateTimestamp = pigeonVar_list[4] as! String
    let consentPurposeText = pigeonVar_list[5] as! String
    let status: String? = nilOrValue(pigeonVar_list[6])

    return NativeUserConsentInfoDetails(
      consentId: consentId,
      consentIntentEntityId: consentIntentEntityId,
      consentIntentEntityName: consentIntentEntityName,
      consentIdList: consentIdList,
      consentIntentUpdateTimestamp: consentIntentUpdateTimestamp,
      consentPurposeText: consentPurposeText,
      status: status
    )
  }
  func toList() -> [Any?] {
    return [
      consentId,
      consentIntentEntityId,
      consentIntentEntityName,
      consentIdList,
      consentIntentUpdateTimestamp,
      consentPurposeText,
      status,
    ]
  }
  static func == (lhs: NativeUserConsentInfoDetails, rhs: NativeUserConsentInfoDetails) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeAccountAggregator: Hashable {
  var id: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeAccountAggregator? {
    let id = pigeonVar_list[0] as! String

    return NativeAccountAggregator(
      id: id
    )
  }
  func toList() -> [Any?] {
    return [
      id
    ]
  }
  static func == (lhs: NativeAccountAggregator, rhs: NativeAccountAggregator) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPReference: Hashable {
  var fipId: String
  var fipName: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFIPReference? {
    let fipId = pigeonVar_list[0] as! String
    let fipName = pigeonVar_list[1] as! String

    return NativeFIPReference(
      fipId: fipId,
      fipName: fipName
    )
  }
  func toList() -> [Any?] {
    return [
      fipId,
      fipName,
    ]
  }
  static func == (lhs: NativeFIPReference, rhs: NativeFIPReference) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentAccountDetails: Hashable {
  var fiType: String
  var fipId: String
  var accountType: String
  var accountReferenceNumber: String? = nil
  var maskedAccountNumber: String
  var linkReferenceNumber: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConsentAccountDetails? {
    let fiType = pigeonVar_list[0] as! String
    let fipId = pigeonVar_list[1] as! String
    let accountType = pigeonVar_list[2] as! String
    let accountReferenceNumber: String? = nilOrValue(pigeonVar_list[3])
    let maskedAccountNumber = pigeonVar_list[4] as! String
    let linkReferenceNumber = pigeonVar_list[5] as! String

    return NativeConsentAccountDetails(
      fiType: fiType,
      fipId: fipId,
      accountType: accountType,
      accountReferenceNumber: accountReferenceNumber,
      maskedAccountNumber: maskedAccountNumber,
      linkReferenceNumber: linkReferenceNumber
    )
  }
  func toList() -> [Any?] {
    return [
      fiType,
      fipId,
      accountType,
      accountReferenceNumber,
      maskedAccountNumber,
      linkReferenceNumber,
    ]
  }
  static func == (lhs: NativeConsentAccountDetails, rhs: NativeConsentAccountDetails) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeLoginOtpReference: Hashable {
  var reference: String
  var snaToken: String? = nil
  var authType: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeLoginOtpReference? {
    let reference = pigeonVar_list[0] as! String
    let snaToken: String? = nilOrValue(pigeonVar_list[1])
    let authType = pigeonVar_list[2] as! String

    return NativeLoginOtpReference(
      reference: reference,
      snaToken: snaToken,
      authType: authType
    )
  }
  func toList() -> [Any?] {
    return [
      reference,
      snaToken,
      authType,
    ]
  }
  static func == (lhs: NativeLoginOtpReference, rhs: NativeLoginOtpReference) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeConsentHandleStatusResponse: Hashable {
  var status: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeConsentHandleStatusResponse? {
    let status = pigeonVar_list[0] as! String

    return NativeConsentHandleStatusResponse(
      status: status
    )
  }
  func toList() -> [Any?] {
    return [
      status
    ]
  }
  static func == (lhs: NativeConsentHandleStatusResponse, rhs: NativeConsentHandleStatusResponse) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPInfo: Hashable {
  var fipId: String
  var productName: String? = nil
  var fipFitypes: [String?]
  var fipFsr: String? = nil
  var productDesc: String? = nil
  var productIconUri: String? = nil
  var enabled: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFIPInfo? {
    let fipId = pigeonVar_list[0] as! String
    let productName: String? = nilOrValue(pigeonVar_list[1])
    let fipFitypes = pigeonVar_list[2] as! [String?]
    let fipFsr: String? = nilOrValue(pigeonVar_list[3])
    let productDesc: String? = nilOrValue(pigeonVar_list[4])
    let productIconUri: String? = nilOrValue(pigeonVar_list[5])
    let enabled = pigeonVar_list[6] as! Bool

    return NativeFIPInfo(
      fipId: fipId,
      productName: productName,
      fipFitypes: fipFitypes,
      fipFsr: fipFsr,
      productDesc: productDesc,
      productIconUri: productIconUri,
      enabled: enabled
    )
  }
  func toList() -> [Any?] {
    return [
      fipId,
      productName,
      fipFitypes,
      fipFsr,
      productDesc,
      productIconUri,
      enabled,
    ]
  }
  static func == (lhs: NativeFIPInfo, rhs: NativeFIPInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeFIPSearchResponse: Hashable {
  var searchOptions: [NativeFIPInfo?]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeFIPSearchResponse? {
    let searchOptions = pigeonVar_list[0] as! [NativeFIPInfo?]

    return NativeFIPSearchResponse(
      searchOptions: searchOptions
    )
  }
  func toList() -> [Any?] {
    return [
      searchOptions
    ]
  }
  static func == (lhs: NativeFIPSearchResponse, rhs: NativeFIPSearchResponse) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct NativeEntityInfo: Hashable {
  var entityId: String
  var entityName: String
  var entityIconUri: String? = nil
  var entityLogoUri: String? = nil
  var entityLogoWithNameUri: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NativeEntityInfo? {
    let entityId = pigeonVar_list[0] as! String
    let entityName = pigeonVar_list[1] as! String
    let entityIconUri: String? = nilOrValue(pigeonVar_list[2])
    let entityLogoUri: String? = nilOrValue(pigeonVar_list[3])
    let entityLogoWithNameUri: String? = nilOrValue(pigeonVar_list[4])

    return NativeEntityInfo(
      entityId: entityId,
      entityName: entityName,
      entityIconUri: entityIconUri,
      entityLogoUri: entityLogoUri,
      entityLogoWithNameUri: entityLogoWithNameUri
    )
  }
  func toList() -> [Any?] {
    return [
      entityId,
      entityName,
      entityIconUri,
      entityLogoUri,
      entityLogoWithNameUri,
    ]
  }
  static func == (lhs: NativeEntityInfo, rhs: NativeEntityInfo) -> Bool {
    return deepEqualsNativeFinvuManager(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNativeFinvuManager(value: toList(), hasher: &hasher)
  }
}

private class NativeFinvuManagerPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FinvuEnv(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      return NativeFinvuSnaAuthConfig.fromList(self.readValue() as! [Any?])
    case 131:
      return NativeFinvuConfig.fromList(self.readValue() as! [Any?])
    case 132:
      return NativeHandleInfo.fromList(self.readValue() as! [Any?])
    case 133:
      return NativeFIPDetails.fromList(self.readValue() as! [Any?])
    case 134:
      return NativeFIPFiTypeIdentifier.fromList(self.readValue() as! [Any?])
    case 135:
      return NativeTypeIdentifier.fromList(self.readValue() as! [Any?])
    case 136:
      return NativeTypeIdentifierInfo.fromList(self.readValue() as! [Any?])
    case 137:
      return NativeDiscoveredAccountInfo.fromList(self.readValue() as! [Any?])
    case 138:
      return NativeDiscoveredAccountsResponse.fromList(self.readValue() as! [Any?])
    case 139:
      return NativeAccountLinkingRequestReference.fromList(self.readValue() as! [Any?])
    case 140:
      return NativeLinkedAccountInfo.fromList(self.readValue() as! [Any?])
    case 141:
      return NativeConfirmAccountLinkingInfo.fromList(self.readValue() as! [Any?])
    case 142:
      return NativeLinkedAccountsResponse.fromList(self.readValue() as! [Any?])
    case 143:
      return NativeLinkedAccountDetailsInfo.fromList(self.readValue() as! [Any?])
    case 144:
      return NativeFinancialInformationEntity.fromList(self.readValue() as! [Any?])
    case 145:
      return NativeConsentPurposeInfo.fromList(self.readValue() as! [Any?])
    case 146:
      return NativeConsentRequestDetailInfo.fromList(self.readValue() as! [Any?])
    case 147:
      return NativeDateTimeRange.fromList(self.readValue() as! [Any?])
    case 148:
      return NativeConsentDataFrequency.fromList(self.readValue() as! [Any?])
    case 149:
      return NativeConsentDataLifePeriod.fromList(self.readValue() as! [Any?])
    case 150:
      return NativeConsentInfo.fromList(self.readValue() as! [Any?])
    case 151:
      return NativeProcessConsentRequestResponse.fromList(self.readValue() as! [Any?])
    case 152:
      return NativeUserConsentInfo.fromList(self.readValue() as! [Any?])
    case 153:
      return NativeUserConsentInfoDetails.fromList(self.readValue() as! [Any?])
    case 154:
      return NativeAccountAggregator.fromList(self.readValue() as! [Any?])
    case 155:
      return NativeFIPReference.fromList(self.readValue() as! [Any?])
    case 156:
      return NativeConsentAccountDetails.fromList(self.readValue() as! [Any?])
    case 157:
      return NativeLoginOtpReference.fromList(self.readValue() as! [Any?])
    case 158:
      return NativeConsentHandleStatusResponse.fromList(self.readValue() as! [Any?])
    case 159:
      return NativeFIPInfo.fromList(self.readValue() as! [Any?])
    case 160:
      return NativeFIPSearchResponse.fromList(self.readValue() as! [Any?])
    case 161:
      return NativeEntityInfo.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class NativeFinvuManagerPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? FinvuEnv {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? NativeFinvuSnaAuthConfig {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFinvuConfig {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? NativeHandleInfo {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPDetails {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPFiTypeIdentifier {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? NativeTypeIdentifier {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? NativeTypeIdentifierInfo {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? NativeDiscoveredAccountInfo {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? NativeDiscoveredAccountsResponse {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAccountLinkingRequestReference {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLinkedAccountInfo {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConfirmAccountLinkingInfo {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLinkedAccountsResponse {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLinkedAccountDetailsInfo {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFinancialInformationEntity {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentPurposeInfo {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentRequestDetailInfo {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? NativeDateTimeRange {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentDataFrequency {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentDataLifePeriod {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentInfo {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? NativeProcessConsentRequestResponse {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserConsentInfo {
      super.writeByte(152)
      super.writeValue(value.toList())
    } else if let value = value as? NativeUserConsentInfoDetails {
      super.writeByte(153)
      super.writeValue(value.toList())
    } else if let value = value as? NativeAccountAggregator {
      super.writeByte(154)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPReference {
      super.writeByte(155)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentAccountDetails {
      super.writeByte(156)
      super.writeValue(value.toList())
    } else if let value = value as? NativeLoginOtpReference {
      super.writeByte(157)
      super.writeValue(value.toList())
    } else if let value = value as? NativeConsentHandleStatusResponse {
      super.writeByte(158)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPInfo {
      super.writeByte(159)
      super.writeValue(value.toList())
    } else if let value = value as? NativeFIPSearchResponse {
      super.writeByte(160)
      super.writeValue(value.toList())
    } else if let value = value as? NativeEntityInfo {
      super.writeByte(161)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NativeFinvuManagerPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return NativeFinvuManagerPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return NativeFinvuManagerPigeonCodecWriter(data: data)
  }
}

class NativeFinvuManagerPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = NativeFinvuManagerPigeonCodec(readerWriter: NativeFinvuManagerPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NativeFinvuManager {
  func initialize(config: NativeFinvuConfig) throws
  func connect(completion: @escaping (Result<Void, Error>) -> Void)
  func disconnect() throws
  func isConnected() throws -> Bool
  func hasSession() throws -> Bool
  func loginWithUsernameOrMobileNumberAndConsentHandle(username: String?, mobileNumber: String?, consentHandleId: String, completion: @escaping (Result<NativeLoginOtpReference, Error>) -> Void)
  func verifyLoginOtp(otp: String, otpReference: String, completion: @escaping (Result<NativeHandleInfo, Error>) -> Void)
  func discoverAccountsAsync(fipId: String, fiTypes: [String], identifiers: [NativeTypeIdentifierInfo], completion: @escaping (Result<NativeDiscoveredAccountsResponse, Error>) -> Void)
  func discoverAccounts(fipId: String, fiTypes: [String], identifiers: [NativeTypeIdentifierInfo], completion: @escaping (Result<NativeDiscoveredAccountsResponse, Error>) -> Void)
  func linkAccounts(fipDetails: NativeFIPDetails, accounts: [NativeDiscoveredAccountInfo], completion: @escaping (Result<NativeAccountLinkingRequestReference, Error>) -> Void)
  func confirmAccountLinking(requestReference: NativeAccountLinkingRequestReference, otp: String, completion: @escaping (Result<NativeConfirmAccountLinkingInfo, Error>) -> Void)
  func fetchLinkedAccounts(completion: @escaping (Result<NativeLinkedAccountsResponse, Error>) -> Void)
  func initiateMobileVerification(mobileNumber: String, completion: @escaping (Result<Void, Error>) -> Void)
  func completeMobileVerification(mobileNumber: String, otp: String, completion: @escaping (Result<Void, Error>) -> Void)
  func fipsAllFIPOptions(completion: @escaping (Result<NativeFIPSearchResponse, Error>) -> Void)
  func fetchFIPDetails(fipId: String, completion: @escaping (Result<NativeFIPDetails, Error>) -> Void)
  func getEntityInfo(entityId: String, entityType: String, completion: @escaping (Result<NativeEntityInfo, Error>) -> Void)
  func approveConsentRequest(consentRequest: NativeConsentRequestDetailInfo, linkedAccounts: [NativeLinkedAccountDetailsInfo], completion: @escaping (Result<NativeProcessConsentRequestResponse, Error>) -> Void)
  func denyConsentRequest(consentRequest: NativeConsentRequestDetailInfo, completion: @escaping (Result<NativeProcessConsentRequestResponse, Error>) -> Void)
  func revokeConsent(consentId: String, accountAggregator: NativeAccountAggregator?, fipDetails: NativeFIPReference?, completion: @escaping (Result<Void, Error>) -> Void)
  func getConsentHandleStatus(handleId: String, completion: @escaping (Result<NativeConsentHandleStatusResponse, Error>) -> Void)
  func getConsentRequestDetails(handleId: String, completion: @escaping (Result<NativeConsentRequestDetailInfo, Error>) -> Void)
  func logout(completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class NativeFinvuManagerSetup {
  static var codec: FlutterStandardMessageCodec { NativeFinvuManagerPigeonCodec.shared }
  /// Sets up an instance of `NativeFinvuManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NativeFinvuManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.initialize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let configArg = args[0] as! NativeFinvuConfig
        do {
          try api.initialize(config: configArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    let connectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.connect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      connectChannel.setMessageHandler { _, reply in
        api.connect { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      connectChannel.setMessageHandler(nil)
    }
    let disconnectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.disconnect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disconnectChannel.setMessageHandler { _, reply in
        do {
          try api.disconnect()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disconnectChannel.setMessageHandler(nil)
    }
    let isConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.isConnected\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isConnectedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isConnected()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isConnectedChannel.setMessageHandler(nil)
    }
    let hasSessionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.hasSession\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasSessionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.hasSession()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasSessionChannel.setMessageHandler(nil)
    }
    let loginWithUsernameOrMobileNumberAndConsentHandleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.loginWithUsernameOrMobileNumberAndConsentHandle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loginWithUsernameOrMobileNumberAndConsentHandleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let usernameArg: String? = nilOrValue(args[0])
        let mobileNumberArg: String? = nilOrValue(args[1])
        let consentHandleIdArg = args[2] as! String
        api.loginWithUsernameOrMobileNumberAndConsentHandle(username: usernameArg, mobileNumber: mobileNumberArg, consentHandleId: consentHandleIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loginWithUsernameOrMobileNumberAndConsentHandleChannel.setMessageHandler(nil)
    }
    let verifyLoginOtpChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.verifyLoginOtp\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      verifyLoginOtpChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let otpArg = args[0] as! String
        let otpReferenceArg = args[1] as! String
        api.verifyLoginOtp(otp: otpArg, otpReference: otpReferenceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      verifyLoginOtpChannel.setMessageHandler(nil)
    }
    let discoverAccountsAsyncChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.discoverAccountsAsync\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      discoverAccountsAsyncChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipIdArg = args[0] as! String
        let fiTypesArg = args[1] as! [String]
        let identifiersArg = args[2] as! [NativeTypeIdentifierInfo]
        api.discoverAccountsAsync(fipId: fipIdArg, fiTypes: fiTypesArg, identifiers: identifiersArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      discoverAccountsAsyncChannel.setMessageHandler(nil)
    }
    let discoverAccountsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.discoverAccounts\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      discoverAccountsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipIdArg = args[0] as! String
        let fiTypesArg = args[1] as! [String]
        let identifiersArg = args[2] as! [NativeTypeIdentifierInfo]
        api.discoverAccounts(fipId: fipIdArg, fiTypes: fiTypesArg, identifiers: identifiersArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      discoverAccountsChannel.setMessageHandler(nil)
    }
    let linkAccountsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.linkAccounts\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      linkAccountsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipDetailsArg = args[0] as! NativeFIPDetails
        let accountsArg = args[1] as! [NativeDiscoveredAccountInfo]
        api.linkAccounts(fipDetails: fipDetailsArg, accounts: accountsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      linkAccountsChannel.setMessageHandler(nil)
    }
    let confirmAccountLinkingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.confirmAccountLinking\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      confirmAccountLinkingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestReferenceArg = args[0] as! NativeAccountLinkingRequestReference
        let otpArg = args[1] as! String
        api.confirmAccountLinking(requestReference: requestReferenceArg, otp: otpArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      confirmAccountLinkingChannel.setMessageHandler(nil)
    }
    let fetchLinkedAccountsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.fetchLinkedAccounts\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fetchLinkedAccountsChannel.setMessageHandler { _, reply in
        api.fetchLinkedAccounts { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      fetchLinkedAccountsChannel.setMessageHandler(nil)
    }
    let initiateMobileVerificationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.initiateMobileVerification\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initiateMobileVerificationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mobileNumberArg = args[0] as! String
        api.initiateMobileVerification(mobileNumber: mobileNumberArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initiateMobileVerificationChannel.setMessageHandler(nil)
    }
    let completeMobileVerificationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.completeMobileVerification\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      completeMobileVerificationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mobileNumberArg = args[0] as! String
        let otpArg = args[1] as! String
        api.completeMobileVerification(mobileNumber: mobileNumberArg, otp: otpArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      completeMobileVerificationChannel.setMessageHandler(nil)
    }
    let fipsAllFIPOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.fipsAllFIPOptions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fipsAllFIPOptionsChannel.setMessageHandler { _, reply in
        api.fipsAllFIPOptions { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      fipsAllFIPOptionsChannel.setMessageHandler(nil)
    }
    let fetchFIPDetailsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.fetchFIPDetails\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      fetchFIPDetailsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fipIdArg = args[0] as! String
        api.fetchFIPDetails(fipId: fipIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      fetchFIPDetailsChannel.setMessageHandler(nil)
    }
    let getEntityInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.getEntityInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEntityInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let entityIdArg = args[0] as! String
        let entityTypeArg = args[1] as! String
        api.getEntityInfo(entityId: entityIdArg, entityType: entityTypeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getEntityInfoChannel.setMessageHandler(nil)
    }
    let approveConsentRequestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.approveConsentRequest\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      approveConsentRequestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let consentRequestArg = args[0] as! NativeConsentRequestDetailInfo
        let linkedAccountsArg = args[1] as! [NativeLinkedAccountDetailsInfo]
        api.approveConsentRequest(consentRequest: consentRequestArg, linkedAccounts: linkedAccountsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      approveConsentRequestChannel.setMessageHandler(nil)
    }
    let denyConsentRequestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.denyConsentRequest\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      denyConsentRequestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let consentRequestArg = args[0] as! NativeConsentRequestDetailInfo
        api.denyConsentRequest(consentRequest: consentRequestArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      denyConsentRequestChannel.setMessageHandler(nil)
    }
    let revokeConsentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.revokeConsent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      revokeConsentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let consentIdArg = args[0] as! String
        let accountAggregatorArg: NativeAccountAggregator? = nilOrValue(args[1])
        let fipDetailsArg: NativeFIPReference? = nilOrValue(args[2])
        api.revokeConsent(consentId: consentIdArg, accountAggregator: accountAggregatorArg, fipDetails: fipDetailsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      revokeConsentChannel.setMessageHandler(nil)
    }
    let getConsentHandleStatusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.getConsentHandleStatus\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getConsentHandleStatusChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let handleIdArg = args[0] as! String
        api.getConsentHandleStatus(handleId: handleIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getConsentHandleStatusChannel.setMessageHandler(nil)
    }
    let getConsentRequestDetailsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.getConsentRequestDetails\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getConsentRequestDetailsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let handleIdArg = args[0] as! String
        api.getConsentRequestDetails(handleId: handleIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getConsentRequestDetailsChannel.setMessageHandler(nil)
    }
    let logoutChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.finvu_flutter_sdk.NativeFinvuManager.logout\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      logoutChannel.setMessageHandler { _, reply in
        api.logout { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      logoutChannel.setMessageHandler(nil)
    }
  }
}
